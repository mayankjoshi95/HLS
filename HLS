HARDWARE:-OUTPUTS
SOFTWARE:-CALL BY REFERENCE ARGUMNETS &FUCNTION RETURN AND NOT USE CALL BY VALUE ARGUMENT 
HARDWARE:-INPUTS
SOFTWARE:-CALL BY VALUE ARGUMENTS
HARDWARE:-INOUTS
SOFTWARE:-CALL BY REFERENCE ARGUMENTS
HARDWARTE:-DESIGN 
SOFTWARE:-FUNCTION BODY 
A SOFTWARE FUNCTION DESCRIBE HARDWARE MODULE 
THE FUNCTION ARGUMENT MODEL THE HARDWARE PORTS 
A FUNCTION BODY IMPLEMENTS HARDWARE BEHAVIOUR 


TO USE THE HARDWARE PORTS 

void ledonoff(unsigned char*o)
{*o=0b11110000
}
port and function interfaces 
void ledonoff(unsigned char*o)
{
#pragmaHLS INTERFACE AP_NONE  PORT=o                                 ##AS WE DON'T HAVE ANY SPECIFIC INTERRFACE IN THIS EXAMPLE AP_NONE is used for this purpose 
#pragmaHLS INTERFACEAP_CTRL_NONE PORT=return                                                                   ##there is also an interface assigned to this whole function 

*o=0b11110000
}


In vivado HLS we 
1.Create a project 
2.add a source file 
3.perform high level synthesis
4.generate IP

TOP FUNCTION :IS THE NAME OF THE HARDWARE MODULE ENTRY FUNCTION .EACH HARDWARE MOPDULE HAVE ON TOP FUNCITON


VIVADO HLS GUI HAS 4 PARTS 

1st has EXPLORER it has includes which is the included header file 
2. source 
3.test bench 



void basic_output(unsigned char*o){
	*o=0b11110000;
}

#Now we should add pragma 
1.adding manually to the source code 
2. use directive 

void FIRST(unsigned char *o){
#pragma HLS INTERFACE ap_none port=o
#pragma HLS INTERFACE ap_ctrl_none port=return
	*o=0b11110000;
}
after it use synthesis and RTL .
we will get the ip then open vivado go to create design and after right click import the ip then click on the plus sign and add the IP .L
there are two pragma 
1.top level function pragma which add the control signal to the synthesized hardware.
2.Port related pragma  
since currently our design is simple thus these two group of pragma doesnot define the right interface.


DESIGN IN VIVADO 


LVCMOS33 
3.3 V LOW VOLTAGE CMOS SINGLE ENDED I/O STANDARD 
TO CONNECT THE IP PORTS INTO THE FPGA PINS ,WE SHOULD DEFINE SOME CONSTRAINTS 
THE MAIN CONSTRAINTS DETERMINE THE PIN LOCATION AND PIN ELECTRICAL STANDARD 



SIMPLE INPUT 
##BASIC INPUT OUTPUT 


#define data_type  unsigned char 

void  basic_input_output(
data_type input
data_type *output){*output=input;}

WHen the top level function is synthesized, the arguments (parameter)to the function are synthesized into RTL ports.This process is called interface synthesis.


port  interface can have various modes

a top funccitoppn in HLS cannot return a pointer value 

#define data_type  unsigned char

void PORT(
data_type input,
data_type *output)
{
#pragma HLS INTERFACE ap_none port=output
#pragma HLS INTERFACE ap_none port=input
#pragma HLS INTERFACE ap_ctrl_none port=return ##ports are assinged as simple wire .

	*output=input;
}

gate propagation delay 
we assume here tp as the gate propagation delay
it takes time for the output to reflect input state changes 
one of opur main goal in hls is to reduce this delay and decreasing this design response time .
serially connected hardware increases the corresponding propagation delay .
As we are using wires to carry logic values we use ap_none or ap_ctrl_none as interface .
Now three parts are usefull for us now i.e timing utilisation and interface .






