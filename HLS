HARDWARE:-OUTPUTS
SOFTWARE:-CALL BY REFERENCE ARGUMNETS &FUCNTION RETURN AND NOT USE CALL BY VALUE ARGUMENT 
HARDWARE:-INPUTS
SOFTWARE:-CALL BY VALUE ARGUMENTS
HARDWARE:-INOUTS
SOFTWARE:-CALL BY REFERENCE ARGUMENTS
HARDWARTE:-DESIGN 
SOFTWARE:-FUNCTION BODY 
A SOFTWARE FUNCTION DESCRIBE HARDWARE MODULE 
THE FUNCTION ARGUMENT MODEL THE HARDWARE PORTS 
A FUNCTION BODY IMPLEMENTS HARDWARE BEHAVIOUR 


TO USE THE HARDWARE PORTS 

void ledonoff(unsigned char*o)
{*o=0b11110000
}
port and function interfaces 
void ledonoff(unsigned char*o)
{
#pragmaHLS INTERFACE AP_NONE  PORT=o                                 ##AS WE DON'T HAVE ANY SPECIFIC INTERRFACE IN THIS EXAMPLE AP_NONE is used for this purpose 
#pragmaHLS INTERFACEAP_CTRL_NONE PORT=return                                                                   ##there is also an interface assigned to this whole function 

*o=0b11110000
}


In vivado HLS we 
1.Create a project 
2.add a source file 
3.perform high level synthesis
4.generate IP

TOP FUNCTION :IS THE NAME OF THE HARDWARE MODULE ENTRY FUNCTION .EACH HARDWARE MOPDULE HAVE ON TOP FUNCITON


VIVADO HLS GUI HAS 4 PARTS 

1st has EXPLORER it has includes which is the included header file 
2. source 
3.test bench 



void basic_output(unsigned char*o){
	*o=0b11110000;
}

#Now we should add pragma 
1.adding manually to the source code 
2. use directive 

void FIRST(unsigned char *o){
#pragma HLS INTERFACE ap_none port=o
#pragma HLS INTERFACE ap_ctrl_none port=return
	*o=0b11110000;
}
after it use synthesis and RTL .
we will get the ip then open vivado go to create design and after right click import the ip then click on the plus sign and add the IP .L
there are two pragma 
1.top level function pragma which add the control signal to the synthesized hardware.
2.Port related pragma  
since currently our design is simple thus these two group of pragma doesnot define the right interface.


DESIGN IN VIVADO 


LVCMOS33 
3.3 V LOW VOLTAGE CMOS SINGLE ENDED I/O STANDARD 
TO CONNECT THE IP PORTS INTO THE FPGA PINS ,WE SHOULD DEFINE SOME CONSTRAINTS 
THE MAIN CONSTRAINTS DETERMINE THE PIN LOCATION AND PIN ELECTRICAL STANDARD 



SIMPLE INPUT 
##BASIC INPUT OUTPUT 


#define data_type  unsigned char 

void  basic_input_output(
data_type input
data_type *output){*output=input;}

WHen the top level function is synthesized, the arguments (parameter)to the function are synthesized into RTL ports.This process is called interface synthesis.


port  interface can have various modes

a top funccitoppn in HLS cannot return a pointer value 

#define data_type  unsigned char

void PORT(
data_type input,
data_type *output)
{
#pragma HLS INTERFACE ap_none port=output
#pragma HLS INTERFACE ap_none port=input
#pragma HLS INTERFACE ap_ctrl_none port=return ##ports are assinged as simple wire .

	*output=input;
}

gate propagation delay 
we assume here tp as the gate propagation delay
it takes time for the output to reflect input state changes 
one of opur main goal in hls is to reduce this delay and decreasing this design response time .
serially connected hardware increases the corresponding propagation delay .
As we are using wires to carry logic values we use ap_none or ap_ctrl_none as interface .
Now three parts are usefull for us now i.e timing utilisation and interface .
In timing part is the estimation of the design propagation delay 

HLS REPORT OF COMBINATIONAL CIIRCUIT SYNTHESIZED BY VIVADO HLS 
1.SHOULD NOT UTILISE ANY MEMORY ELEMENT 
2.SHOULD NOT HAVE ANY CLOCK PORT IN THE INTERFACE PART 


##now to analyse use the analysis which tells about the synthesis .
Control states are the internal state that high level synthesis uses to schedule opeeration
combinational circuit perform all its logical operation in a single state denoted by 0.


RULES FOR USING FUNCTIONS IN VIVADO HLS 

1.MUST CONTAIN THE ENTIRE FUNCTIONALITY .
2.THEY CAN BE ORGANISED INTO THE LIBRARIES.
SYSTEM CALLS TO THE OPERATING SYSTEM ARE NOT ALLOWED .
LIKE SLEEEP(),GETC(),TIME()
THESE CAN BE USED IN HTE TEST BENCH FUNCTION BUT NOT IN THE DESGIN FUNCTION
VIVADO HLS IGNORES COMMONLY USED SYSTEM CALLS SUCH AS COUT AND PRINTF
TOP FUNCTION CANNOT BE A STATIC FUNCTION
 
 
 INTEFACE SYNTHESIS 
 ARGUMENT IN THE TOP LEVEL FUNCTION ARE DEFINED AS THE PORTS 
 SUB FUNCTIONS CAN BE INLINED TO MERGE THERE LOGIC WIHT THE LOGIC OF THE SURROUNDING FUNCTION .
 INLING CAN ALSO INCRESE THE RUN TIME.
 
 
##now to see how can we model a structure of a combinational code inside a function to better understand the synthesis process behaviour  
 bool not_gate(bool a ){
#pragma HLS INLINE off


	return !a;

}
bool and_gate(bool a,bool b){
#pragma HLS INLINE off
	return(a & b);
}

void automatic_inline(bool a ,bool b,bool *c){
#pragma HLS INTERFACE ap_none port=c
#pragma HLS INTERFACE ap_none port=b
#pragma HLS INTERFACE ap_none port=a
#pragma HLS INTERFACE ap_ctrl_none port=return
	*c= and_gate(not_gate(a),  b);
}


DATA FLOW REPRESENT MOVEMENT OF A DESIGN FROM INPUT TO A OUTPUT 
THE GRAPH IS A DIRECTED GRAPH IN WHICH OPERATOR SUCH AS LOGICAL ARITHMETIC AND ASSIGNMENT OPERATOR ARE REPRESENTED BY THE GRAPH NODES AND INFORMATION FLOW IS REPRESNTED BY THE ARGS 
 ACYCLIC DATA FLOW GRAPH IS A DATA FLOW GRAP[H WITHOUT A CYCLE PATH  



C TEST BENCH 

COMBINATION OF DESIGN HAS AN INPUTS AND OUTPUTS .THE ROLE OF SIMULATION IS TO APPLY ALL POSSIBLE INPUTS AND TO CHECK THE OUTPUTS COMPARING WITH THE GOLDEN MODEL PRPOVIDED BY THE DESIGN SPECIFICATION.
SIMULKATION IS A VERIFICATION TECHNIQUE PROVIDED BY THE HLS TOOL 

TEST BENCH HAS  4 PARTS

1.GENERATE INPUTS
2.APPLY INPUTS TO THE DESIGN 
3.APPLY INPUTS TO THE GOLDEN MODELS
4.COMPARE THE OUTPUTS OF THE DESIGN AND THE GOLDEN MODEL.


NATIVE C++ DATA TYPE 
BOOL ,CHAR ,INT 
MODIFIER SIGNED UNSIGNED LONG
FLOAT ,DOUBLE DATA TYPE WHICH IS ALSO CALLED SINGLE PRECISION FLOAT IS OF 32 BIT AND DOUBLE DATA TYPE IS OF 64 BIT .
vivdo HLS support float and double data type 
for combionational we donot use memory cell so all are mapped in the wire 

clock period constrained should be higher than the circuit propagatrion delay


BIT PRECISION DECLARATION

VIVADO PROVIDE AN ARBITRARY PRECISION DATA TYPE LIBRARY 
THIS LIBRARY SUPPORTS BOTH ARBITRARY PRECISION DATA TYPES FOR BOTH SIMULATION ADN SYNTHESIS
IT COMES IN TWO FLAVOUR 
1. FOR C 
2 .FOR C++

INTEGER PRECISION DATA TYPE
IN ORDER TO USE THIS LIBRARY WE HAVE TO USE HEADER FFILE 

#include<ap_int.h>
example 
#include "ap_int.h"
ap_int<5> a;# 5 bit signed integer value 
ap_uint<11> b;8 bit unsigned integer value 

ap int and ap uint template provides all the arithmetic,bitwise ,logical and relational operator 

this LIBRARY SUPPORTS ARBITRARY BIT WIDTH 1 TO 1024 BITS ##we can overwrite this default by 

#define AP_INT_MAX_W  8192
#include "ap_int.h"
ap_int<8192>wide_a;

##WHAT ARE HTE RULES OF ASSIGNING VALUES TO THESE VARIABLE 

VARIABLE ASSIGNMEBT IS POSSIBLE BECAUSE OF THE CLASS CONSTRUCTOR AND OVERLOADED ASSIGNMENT OPERATOR 

ap_int<17>a=0x17e;
ap_uint<57>b=0xef42ed12cf72abULL;#it can represent number upto 64 bits.
To allow assignment of values wider than 64 bits constructors are provided

CONSTRUCTOR GETS TWO ASSIGNMENT A STRING REPRESENTING A VALUES AND A RADIX.
ap_[u]int<w> a=ap_[u]int<w>(string,radix);
ap_[u]int<w> a (string,radix);

ap_int<41> a1=04017;
ap_int<41> a1=ap_int<41>("4017",8);
ap_int<763> a1=ap_int<763>("4017401740174017",16);
values can be printed in the test bench using "cout" 
std::cout<<"b="<<std::oct<<b<<std::endl;


ASSIGNMENT USING BIT PRECISION 

=,+=,-=,*=,/=,%=,<<=,>>=,&=^=,|=.

IF BIT WIDTH OF TWO VARIABLE ARE NOT THE SAME 

ap_int<10>a;
ap_uint<17>b;
ap_int<8>c;

3 Technique handle this situation 
1.SIGN EXTENSION
2.ZERO EXTENSION
3.TRUNCATION

ap_int<7> a=0x5a;#1011010
ap_int<10>b;#1111011010
ap_uint<7> a=0x5a;
ap_int<10>f ;#0001011010
f=a;

TRUNCATION 

IT CAN LEAD TO UNEXPECTED BEHAVIOUR.


##bit precision in print 

the memeber function called to_string converts the valueof an arbitrary precision integer data types into the corresponding C++ string .



##BIT LEVEL OPERATION AVAILABLE IN VIVADO HLS 
1.length () memeber fucntion return the widht of an arbitrary precision data types 
ap_int<41>a=0x23462af;
int len=a.length();
len=41;
#THIS FUCNITON IS SYNTHESIZABLE AND CAN BE USED IN DESIGN AND TEST BENCH FILE 

##CONCATENATION :the concat member function combines two variable \
ap_int<5> b=0x3;
ap_int<7> c=0x13;
ap_int<12> r1=b.concat(c);
ap_int<12> r1=(b,c);
##OVERLOADED OPERATOR 

LSB POSIITON IS 0 AND THE MSB IS 6 FOR A 7 BIT
ap_int<7> c=0x2f;
int i=4;
ap_uint<1> one_bit=n[i];
n[i]=1;

using the range memeber function

ap_uint<4>r;
ap_uint<9>p=0xef;
r=p.range(3,0);


BITWISE LOGICAL OPERATOR 
THEY ARE TRATED AS UNSIGNED ONLY IF BOTH OPERAND ARE OF THE SIGNED TYPE 
BITWISE OR |
BITWISE AND &
BITWISE XOR ^
BITWISE INVERSE ~

ap_int<7> a=0x2f;
ap_int<7> b=0x31;


REDUCE LOGICAL FUNCTION 

IT APLIES AN OPERATOR TO ALL BITS 
AND reduce....... and_reduce()
OR reduce....... or_reduce()
NAND reduce....... nand_reduce()
XOR reduce....... xor_reduce()
NOR reduce....... nor_reduce()
XNOR reduce....... xnor_reduce()

for example 
ap_int<7>a=0x2f;
reduced xor =1


#BIT REVERSE 

reverse()
ap_int<7>a=0X2f;;
a.reverse();


