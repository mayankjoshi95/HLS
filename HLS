HARDWARE:-OUTPUTS
SOFTWARE:-CALL BY REFERENCE ARGUMNETS &FUCNTION RETURN AND NOT USE CALL BY VALUE ARGUMENT 
HARDWARE:-INPUTS
SOFTWARE:-CALL BY VALUE ARGUMENTS
HARDWARE:-INOUTS
SOFTWARE:-CALL BY REFERENCE ARGUMENTS
HARDWARTE:-DESIGN 
SOFTWARE:-FUNCTION BODY 
A SOFTWARE FUNCTION DESCRIBE HARDWARE MODULE 
THE FUNCTION ARGUMENT MODEL THE HARDWARE PORTS 
A FUNCTION BODY IMPLEMENTS HARDWARE BEHAVIOUR 


TO USE THE HARDWARE PORTS 

void ledonoff(unsigned char*o)
{*o=0b11110000
}
port and function interfaces 
void ledonoff(unsigned char*o)
{
#pragmaHLS INTERFACE AP_NONE  PORT=o                                 ##AS WE DON'T HAVE ANY SPECIFIC INTERRFACE IN THIS EXAMPLE AP_NONE is used for this purpose 
#pragmaHLS INTERFACEAP_CTRL_NONE PORT=return                                                                   ##there is also an interface assigned to this whole function 

*o=0b11110000
}


In vivado HLS we 
1.Create a project 
2.add a source file 
3.perform high level synthesis
4.generate IP

TOP FUNCTION :IS THE NAME OF THE HARDWARE MODULE ENTRY FUNCTION .EACH HARDWARE MOPDULE HAVE ON TOP FUNCITON


VIVADO HLS GUI HAS 4 PARTS 

1st has EXPLORER it has includes which is the included header file 
2. source 
3.test bench 



void basic_output(unsigned char*o){
	*o=0b11110000;
}

#Now we should add pragma 
1.adding manually to the source code 
2. use directive 

void FIRST(unsigned char *o){
#pragma HLS INTERFACE ap_none port=o
#pragma HLS INTERFACE ap_ctrl_none port=return
	*o=0b11110000;
}
after it use synthesis and RTL .
we will get the ip then open vivado go to create design and after right click import the ip then click on the plus sign and add the IP .L
there are two pragma 
1.top level function pragma which add the control signal to the synthesized hardware.
2.Port related pragma  
since currently our design is simple thus these two group of pragma doesnot define the right interface.


DESIGN IN VIVADO 


LVCMOS33 
3.3 V LOW VOLTAGE CMOS SINGLE ENDED I/O STANDARD 
TO CONNECT THE IP PORTS INTO THE FPGA PINS ,WE SHOULD DEFINE SOME CONSTRAINTS 
THE MAIN CONSTRAINTS DETERMINE THE PIN LOCATION AND PIN ELECTRICAL STANDARD 



SIMPLE INPUT 
##BASIC INPUT OUTPUT 


#define data_type  unsigned char 

void  basic_input_output(
data_type input
data_type *output){*output=input;}

WHen the top level function is synthesized, the arguments (parameter)to the function are synthesized into RTL ports.This process is called interface synthesis.


port  interface can have various modes

a top funccitoppn in HLS cannot return a pointer value 

#define data_type  unsigned char

void PORT(
data_type input,
data_type *output)
{
#pragma HLS INTERFACE ap_none port=output
#pragma HLS INTERFACE ap_none port=input
#pragma HLS INTERFACE ap_ctrl_none port=return ##ports are assinged as simple wire .

	*output=input;
}

gate propagation delay 
we assume here tp as the gate propagation delay
it takes time for the output to reflect input state changes 
one of opur main goal in hls is to reduce this delay and decreasing this design response time .
serially connected hardware increases the corresponding propagation delay .
As we are using wires to carry logic values we use ap_none or ap_ctrl_none as interface .
Now three parts are usefull for us now i.e timing utilisation and interface .
In timing part is the estimation of the design propagation delay 

HLS REPORT OF COMBINATIONAL CIIRCUIT SYNTHESIZED BY VIVADO HLS 
1.SHOULD NOT UTILISE ANY MEMORY ELEMENT 
2.SHOULD NOT HAVE ANY CLOCK PORT IN THE INTERFACE PART 


##now to analyse use the analysis which tells about the synthesis .
Control states are the internal state that high level synthesis uses to schedule opeeration
combinational circuit perform all its logical operation in a single state denoted by 0.


RULES FOR USING FUNCTIONS IN VIVADO HLS 

1.MUST CONTAIN THE ENTIRE FUNCTIONALITY .
2.THEY CAN BE ORGANISED INTO THE LIBRARIES.
SYSTEM CALLS TO THE OPERATING SYSTEM ARE NOT ALLOWED .
LIKE SLEEEP(),GETC(),TIME()
THESE CAN BE USED IN HTE TEST BENCH FUNCTION BUT NOT IN THE DESGIN FUNCTION
VIVADO HLS IGNORES COMMONLY USED SYSTEM CALLS SUCH AS COUT AND PRINTF
TOP FUNCTION CANNOT BE A STATIC FUNCTION
 
 
 INTEFACE SYNTHESIS 
 ARGUMENT IN THE TOP LEVEL FUNCTION ARE DEFINED AS THE PORTS 
 SUB FUNCTIONS CAN BE INLINED TO MERGE THERE LOGIC WIHT THE LOGIC OF THE SURROUNDING FUNCTION .
 INLING CAN ALSO INCRESE THE RUN TIME.
 
 
##now to see how can we model a structure of a combinational code inside a function to better understand the synthesis process behaviour  
 bool not_gate(bool a ){
#pragma HLS INLINE off


	return !a;

}
bool and_gate(bool a,bool b){
#pragma HLS INLINE off
	return(a & b);
}

void automatic_inline(bool a ,bool b,bool *c){
#pragma HLS INTERFACE ap_none port=c
#pragma HLS INTERFACE ap_none port=b
#pragma HLS INTERFACE ap_none port=a
#pragma HLS INTERFACE ap_ctrl_none port=return
	*c= and_gate(not_gate(a),  b);
}


DATA FLOW REPRESENT MOVEMENT OF A DESIGN FROM INPUT TO A OUTPUT 
THE GRAPH IS A DIRECTED GRAPH IN WHICH OPERATOR SUCH AS LOGICAL ARITHMETIC AND ASSIGNMENT OPERATOR ARE REPRESENTED BY THE GRAPH NODES AND INFORMATION FLOW IS REPRESNTED BY THE ARGS 
 ACYCLIC DATA FLOW GRAPH IS A DATA FLOW GRAP[H WITHOUT A CYCLE PATH  



C TEST BENCH 

COMBINATION OF DESIGN HAS AN INPUTS AND OUTPUTS .THE ROLE OF SIMULATION IS TO APPLY ALL POSSIBLE INPUTS AND TO CHECK THE OUTPUTS COMPARING WITH THE GOLDEN MODEL PRPOVIDED BY THE DESIGN SPECIFICATION.
SIMULKATION IS A VERIFICATION TECHNIQUE PROVIDED BY THE HLS TOOL 

TEST BENCH HAS  4 PARTS

1.GENERATE INPUTS
2.APPLY INPUTS TO THE DESIGN 
3.APPLY INPUTS TO THE GOLDEN MODELS
4.COMPARE THE OUTPUTS OF THE DESIGN AND THE GOLDEN MODEL.









