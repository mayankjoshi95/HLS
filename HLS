HARDWARE:-OUTPUTS
SOFTWARE:-CALL BY REFERENCE ARGUMNETS &FUCNTION RETURN AND NOT USE CALL BY VALUE ARGUMENT 
HARDWARE:-INPUTS
SOFTWARE:-CALL BY VALUE ARGUMENTS
HARDWARE:-INOUTS
SOFTWARE:-CALL BY REFERENCE ARGUMENTS
HARDWARTE:-DESIGN 
SOFTWARE:-FUNCTION BODY 
A SOFTWARE FUNCTION DESCRIBE HARDWARE MODULE 
THE FUNCTION ARGUMENT MODEL THE HARDWARE PORTS 
A FUNCTION BODY IMPLEMENTS HARDWARE BEHAVIOUR 


TO USE THE HARDWARE PORTS 

void ledonoff(unsigned char*o)
{*o=0b11110000
}
port and function interfaces 
void ledonoff(unsigned char*o)
{
#pragmaHLS INTERFACE AP_NONE  PORT=o                                 ##AS WE DON'T HAVE ANY SPECIFIC INTERRFACE IN THIS EXAMPLE AP_NONE is used for this purpose 
#pragmaHLS INTERFACEAP_CTRL_NONE PORT=return                                                                   ##there is also an interface assigned to this whole function 

*o=0b11110000
}


In vivado HLS we 
1.Create a project 
2.add a source file 
3.perform high level synthesis
4.generate IP

TOP FUNCTION :IS THE NAME OF THE HARDWARE MODULE ENTRY FUNCTION .EACH HARDWARE MOPDULE HAVE ON TOP FUNCITON


VIVADO HLS GUI HAS 4 PARTS 

1st has EXPLORER it has includes which is the included header file 
2. source 
3.test bench 



void basic_output(unsigned char*o){
	*o=0b11110000;
}

#Now we should add pragma 
1.adding manually to the source code 
2. use directive 

void FIRST(unsigned char *o){
#pragma HLS INTERFACE ap_none port=o
#pragma HLS INTERFACE ap_ctrl_none port=return
	*o=0b11110000;
}
after it use synthesis and RTL .
we will get the ip then open vivado go to create design and after right click import the ip then click on the plus sign and add the IP .L
there are two pragma 
1.top level function pragma which add the control signal to the synthesized hardware.
2.Port related pragma  
since currently our design is simple thus these two group of pragma doesnot define the right interface.


DESIGN IN VIVADO 


LVCMOS33 
3.3 V LOW VOLTAGE CMOS SINGLE ENDED I/O STANDARD 
TO CONNECT THE IP PORTS INTO THE FPGA PINS ,WE SHOULD DEFINE SOME CONSTRAINTS 
THE MAIN CONSTRAINTS DETERMINE THE PIN LOCATION AND PIN ELECTRICAL STANDARD 



SIMPLE INPUT 
##BASIC INPUT OUTPUT 


#define data_type  unsigned char 

void  basic_input_output(
data_type input
data_type *output){*output=input;}

WHen the top level function is synthesized, the arguments (parameter)to the function are synthesized into RTL ports.This process is called interface synthesis.


port  interface can have various modes

a top funccitoppn in HLS cannot return a pointer value 

#define data_type  unsigned char

void PORT(
data_type input,
data_type *output)
{
#pragma HLS INTERFACE ap_none port=output
#pragma HLS INTERFACE ap_none port=input
#pragma HLS INTERFACE ap_ctrl_none port=return ##ports are assinged as simple wire .

	*output=input;
}

gate propagation delay 
we assume here tp as the gate propagation delay
it takes time for the output to reflect input state changes 
one of opur main goal in hls is to reduce this delay and decreasing this design response time .
serially connected hardware increases the corresponding propagation delay .
As we are using wires to carry logic values we use ap_none or ap_ctrl_none as interface .
Now three parts are usefull for us now i.e timing utilisation and interface .
In timing part is the estimation of the design propagation delay 

HLS REPORT OF COMBINATIONAL CIIRCUIT SYNTHESIZED BY VIVADO HLS 
1.SHOULD NOT UTILISE ANY MEMORY ELEMENT 
2.SHOULD NOT HAVE ANY CLOCK PORT IN THE INTERFACE PART 


##now to analyse use the analysis which tells about the synthesis .
Control states are the internal state that high level synthesis uses to schedule opeeration
combinational circuit perform all its logical operation in a single state denoted by 0.


RULES FOR USING FUNCTIONS IN VIVADO HLS 

1.MUST CONTAIN THE ENTIRE FUNCTIONALITY .
2.THEY CAN BE ORGANISED INTO THE LIBRARIES.
SYSTEM CALLS TO THE OPERATING SYSTEM ARE NOT ALLOWED .
LIKE SLEEEP(),GETC(),TIME()
THESE CAN BE USED IN HTE TEST BENCH FUNCTION BUT NOT IN THE DESGIN FUNCTION
VIVADO HLS IGNORES COMMONLY USED SYSTEM CALLS SUCH AS COUT AND PRINTF
TOP FUNCTION CANNOT BE A STATIC FUNCTION
 
 
 INTEFACE SYNTHESIS 
 ARGUMENT IN THE TOP LEVEL FUNCTION ARE DEFINED AS THE PORTS 
 SUB FUNCTIONS CAN BE INLINED TO MERGE THERE LOGIC WIHT THE LOGIC OF THE SURROUNDING FUNCTION .
 INLING CAN ALSO INCRESE THE RUN TIME.
 
 
##now to see how can we model a structure of a combinational code inside a function to better understand the synthesis process behaviour  
 bool not_gate(bool a ){
#pragma HLS INLINE off


	return !a;

}
bool and_gate(bool a,bool b){
#pragma HLS INLINE off
	return(a & b);
}

void automatic_inline(bool a ,bool b,bool *c){
#pragma HLS INTERFACE ap_none port=c
#pragma HLS INTERFACE ap_none port=b
#pragma HLS INTERFACE ap_none port=a
#pragma HLS INTERFACE ap_ctrl_none port=return
	*c= and_gate(not_gate(a),  b);
}


DATA FLOW REPRESENT MOVEMENT OF A DESIGN FROM INPUT TO A OUTPUT 
THE GRAPH IS A DIRECTED GRAPH IN WHICH OPERATOR SUCH AS LOGICAL ARITHMETIC AND ASSIGNMENT OPERATOR ARE REPRESENTED BY THE GRAPH NODES AND INFORMATION FLOW IS REPRESNTED BY THE ARGS 
 ACYCLIC DATA FLOW GRAPH IS A DATA FLOW GRAP[H WITHOUT A CYCLE PATH  



C TEST BENCH 

COMBINATION OF DESIGN HAS AN INPUTS AND OUTPUTS .THE ROLE OF SIMULATION IS TO APPLY ALL POSSIBLE INPUTS AND TO CHECK THE OUTPUTS COMPARING WITH THE GOLDEN MODEL PRPOVIDED BY THE DESIGN SPECIFICATION.
SIMULKATION IS A VERIFICATION TECHNIQUE PROVIDED BY THE HLS TOOL 

TEST BENCH HAS  4 PARTS

1.GENERATE INPUTS
2.APPLY INPUTS TO THE DESIGN 
3.APPLY INPUTS TO THE GOLDEN MODELS
4.COMPARE THE OUTPUTS OF THE DESIGN AND THE GOLDEN MODEL.


NATIVE C++ DATA TYPE 
BOOL ,CHAR ,INT 
MODIFIER SIGNED UNSIGNED LONG
FLOAT ,DOUBLE DATA TYPE WHICH IS ALSO CALLED SINGLE PRECISION FLOAT IS OF 32 BIT AND DOUBLE DATA TYPE IS OF 64 BIT .
vivdo HLS support float and double data type 
for combionational we donot use memory cell so all are mapped in the wire 

clock period constrained should be higher than the circuit propagatrion delay


BIT PRECISION DECLARATION

VIVADO PROVIDE AN ARBITRARY PRECISION DATA TYPE LIBRARY 
THIS LIBRARY SUPPORTS BOTH ARBITRARY PRECISION DATA TYPES FOR BOTH SIMULATION ADN SYNTHESIS
IT COMES IN TWO FLAVOUR 
1. FOR C 
2 .FOR C++

INTEGER PRECISION DATA TYPE
IN ORDER TO USE THIS LIBRARY WE HAVE TO USE HEADER FFILE 

#include<ap_int.h>
example 
#include "ap_int.h"
ap_int<5> a;# 5 bit signed integer value 
ap_uint<11> b;8 bit unsigned integer value 

ap int and ap uint template provides all the arithmetic,bitwise ,logical and relational operator 

this LIBRARY SUPPORTS ARBITRARY BIT WIDTH 1 TO 1024 BITS ##we can overwrite this default by 

#define AP_INT_MAX_W  8192
#include "ap_int.h"
ap_int<8192>wide_a;

##WHAT ARE HTE RULES OF ASSIGNING VALUES TO THESE VARIABLE 

VARIABLE ASSIGNMEBT IS POSSIBLE BECAUSE OF THE CLASS CONSTRUCTOR AND OVERLOADED ASSIGNMENT OPERATOR 

ap_int<17>a=0x17e;
ap_uint<57>b=0xef42ed12cf72abULL;#it can represent number upto 64 bits.
To allow assignment of values wider than 64 bits constructors are provided

CONSTRUCTOR GETS TWO ASSIGNMENT A STRING REPRESENTING A VALUES AND A RADIX.
ap_[u]int<w> a=ap_[u]int<w>(string,radix);
ap_[u]int<w> a (string,radix);

ap_int<41> a1=04017;
ap_int<41> a1=ap_int<41>("4017",8);
ap_int<763> a1=ap_int<763>("4017401740174017",16);
values can be printed in the test bench using "cout" 
std::cout<<"b="<<std::oct<<b<<std::endl;


ASSIGNMENT USING BIT PRECISION 

=,+=,-=,*=,/=,%=,<<=,>>=,&=^=,|=.

IF BIT WIDTH OF TWO VARIABLE ARE NOT THE SAME 

ap_int<10>a;
ap_uint<17>b;
ap_int<8>c;

3 Technique handle this situation 
1.SIGN EXTENSION
2.ZERO EXTENSION
3.TRUNCATION

ap_int<7> a=0x5a;#1011010
ap_int<10>b;#1111011010
ap_uint<7> a=0x5a;
ap_int<10>f ;#0001011010
f=a;

TRUNCATION 

IT CAN LEAD TO UNEXPECTED BEHAVIOUR.


##bit precision in print 

the memeber function called to_string converts the valueof an arbitrary precision integer data types into the corresponding C++ string .



##BIT LEVEL OPERATION AVAILABLE IN VIVADO HLS 
1.length () memeber fucntion return the widht of an arbitrary precision data types 
ap_int<41>a=0x23462af;
int len=a.length();
len=41;
#THIS FUCNITON IS SYNTHESIZABLE AND CAN BE USED IN DESIGN AND TEST BENCH FILE 

##CONCATENATION :the concat member function combines two variable \
ap_int<5> b=0x3;
ap_int<7> c=0x13;
ap_int<12> r1=b.concat(c);
ap_int<12> r1=(b,c);
##OVERLOADED OPERATOR 

LSB POSIITON IS 0 AND THE MSB IS 6 FOR A 7 BIT
ap_int<7> c=0x2f;
int i=4;
ap_uint<1> one_bit=n[i];
n[i]=1;

using the range memeber function

ap_uint<4>r;
ap_uint<9>p=0xef;
r=p.range(3,0);


BITWISE LOGICAL OPERATOR 
THEY ARE TRATED AS UNSIGNED ONLY IF BOTH OPERAND ARE OF THE SIGNED TYPE 
BITWISE OR |
BITWISE AND &
BITWISE XOR ^
BITWISE INVERSE ~

ap_int<7> a=0x2f;
ap_int<7> b=0x31;


REDUCE LOGICAL FUNCTION 

IT APLIES AN OPERATOR TO ALL BITS 
AND reduce....... and_reduce()
OR reduce....... or_reduce()
NAND reduce....... nand_reduce()
XOR reduce....... xor_reduce()
NOR reduce....... nor_reduce()
XNOR reduce....... xnor_reduce()

for example 
ap_int<7>a=0x2f;
reduced xor =1


#BIT REVERSE 

reverse()
ap_int<7>a=0X2f;;
a.reverse();


ap_int<7>a=0X2f;;
##TEST /SET/CLEAR.
test(i)  bol t=a.test(5)
returns TRUE if yes and FALSE if no.
set(i,v)  a.set(5,0);
bool t=a.test(5);
sets the denoted bit 5 to 0

set(i) sets the denoted bit specified by i to 1

clear(i) sets the denoted bit by 0;


##SHIFT OPERATOR 

OVERLOADED SHIFT OPERATOR AVAILABLE FOR HLS ARBITRARY PRECISION DATA TYPES 

THERE ARE TWO BITWISE SHIFT OPERATOR RIGHT SHIFT (>>) AND LEFT SHIFT <<

ap_int<7>a=0X2f;

ap_int<7>b=a>>3;


ap_int<7>a=0X2f;

ap_int<7>b=a<<3;
a<<-3 means a>>3
b.rrotate(3);
b.lrotate(3);


To drive a set of 7 segment two group of signal are required 
1 DATA signal 
2.CONTROL signal 

Common anode 0 = ON and 1= OFF
Common cathode 0=OFF and 1=ON

TAKEAWAY 

design steps 

1. get the digits 
2.encode the digit 
3.drive the 7 segment with the code 

BCD code types 

1.PACKED:- IT NEEDS ONE BYTES 
2.UNPACKED :-IT NEEDS TWO BYTES 


DESIGNING A CIRCUIT TO CONVERT ITS BINARY TO BCD FORMAT IS OUR NEXT TOPIC


Combinational loop

for(int i=0;i<3;i++)
task1;
task2;
}


Scenario 1
each task is dependent on the previous task sequential is expected 
Scenario2
all task1 can be executed in parallel 
all tassk2 can be executed in parallel

Scenario 3
all task are independent as they work on different data 

FOR EX:
an N bit binary adder is a combinational hardware circuit with a repetitive computational pattern

it uses N full adder in order to add 2 N bit binary number 


N bit is a one counter which gives binary representation of number of ones in a binary representation of a given number .


for loop condition to describe repetitive combinational pattern in HLS 


FOR UNROLLING CONCEPT 

ONLY LOOPS WITH STATIC BOUND WHICHARE FIXED AND KNOWN AT COMPILE TIME CAN BE UNRROLLED BY THE HLS TOOL

#define N 100
for(int i=0;i<N;i++)
{
#pragma HLS UNROLL
task();
}
To unroll a loop completely
to loop bounds must be known at the compile time .
there should be enough resources on FPGA e.g enough LUT

Parity Bit Definiton
Parity Bit is a technique to detect single bit error in a binary data 
Parity is a simple mechaniosm to detect single bit error in a binary data 
a parity generator receive the data and generate the parity 
Laater the parity bit checker check the parity of the data and parioty and tell if there are any error.

There are two types of Parity odd parity:i.e the total number of ones in abinary value is odd and even parity 

Parity for W bit data

p =d[0] xor d[1] xor d[2] xor d[3] xor d[4] xor d[W-1]
pe=p
po=not(p)
Totl propagation delay is =(W-1)*delta 

How to reduce circuit propagation delay 

The chain of XOR gates can implement the parity bit generator 

How CAN WE REDUCE PROPAGATION DELAY 
TO MAKE THE CODSSE IN THEOFMR OF A BALANCED TREE
THEREFORE THIS BALANCED TREE IMPLEMENT THE FORM OF THE GENREATOR


DESCRIBE PARITY BIT GENERATOR IN HLS

an unrolled for-loop representing the parity bit genrator can be synthesized combinational circuit.

HLS can synthesize basic arithmetic operator into the combioantional circuit without any extra work for designer 

Basic arithmetic operator 
+,-/,*,%


there are two types of arithmetic operator in vivado HLS combiantional and pipelined

the pipelined implementation  uses a set of memeory cells called flip flop


##if clock period is greater than  desgin propagation delay then iti ssynthesized into the combinational circuit 
##if clock peirod is less than design  propagation delasy then it is synthesized into the sequebntial ciruuit 


HLS tool can automatically synthesize arithmetic operations on the native C data types
Combinational circuits can implement an arthimetic expression
the arthimetic operation can be implemented by LUT or DSP.



OPERATOR OVERLOADING 
WIRTING
There is clock constraints to each HLS design.

DESIGN YIMING CONSTRAINTS
IF THE TOTAL PROPAGATION DELAY IS LESS THAN A CLOCK PERIOD AND THE DESIGN DOESNOT USE ANY MEMORY CELL THE HLS TOOLDROP THE CLOCK SIGNAL DURING SYNTHESIS AND GENRATE A FULLY COMBIANTIONAL CIRCUIT
IF THE CLOCK PERIOD IS LESS THAN THE PROPAGATION DELAY THE HIGH LEVEL SYNTHESIS TOOL AUTOMATICALLY SCHEDUELS THE 

DSP RESOURCES 

TRADITIONALLY FPGA USES LOGIC GATES TO DESCRIBE ARTHIMETIC EXPRESSISON THIS SOLUTION IS ADEQUATE WITH A FEW ARITHMETIC OPERATION HOWEVER APPLICATION WITH COMPLEX CMPUTAITON WILL REQUIRE MORE
EFFICIENT IMPLEMENTATION TECHNIQUE TO COPE WITH THIS DEMAND ADVANCED FPGA REQUIRE DSP BLOCK CAPABLE OFG PERFORMING HIGH PERFORMANCE ARITHMETIC OPERATION .
THUS THERE ARE TWO DIFFERENT RESOURCES LOOK UP TABLE AND DSP RESOURCES .


DSP IS THE MOST CPOMPLEX COMPUTATIONAL BLOCK AVAILABLE IN FPGA XILINK.
A TYPICAL DSP BLOCK PASS IT THROUGH A TYPICAL ADDITION AND RECONFIGURABLE MODULE.
AL,MOST ALL THE DATA PATH INSIDE THE DSP ARE RECONFIGURABLE 

HLS TOOL CONFIGURE ALL THE TASK AUTOMATICALLY 

DSP STRUCTURE 
1. MULTIPLIER ACCEPTS A 25 BIT SAND 18 BIT 2'S COMPLEMENT INPUT  AND GENRATE A 43 BIT 2'S COMPLEMENT OUTPUT.
INPUTS ARE VIS PRE ADDER MODULEA DN GIVE RESULT TO POST ADDER OUTPUT








####HLS DESIGN WITH ITS FOCUS ON FPGA CIRCUIT USING SEQUENTIAL CIRCUIT


HW/SW CONCEPT

STEPS 
1.DESIGN
2.SIMULATION
3.ANALYSIS
4.SYNTHESIS
5.IMPLEMENTATION
6.BITSTREAM


D Flip Flop 

Memory Cell

Circuit which store Data temporially or permanently these types of circuits are called sequential circuit 


Flip Flop has two input signal which are DATA AND CLOCK and the ouput signal isthe flip flop state.
The data cannot be saved in the memory Until the clock gives the permission.this permission happens at the edge of the clock .

How Does a memory cell use a typical FPGA in a sequential circuit?
sequential circuit has the combinational circuit that perform the logic of the task that stores the state execution sequance and transfer data between these sequences
As memories commonly use D flip flop as tthere building blocks a clock signal should determine the time boundaries between two sequences of execution and triggers saving the state and data generated by the combinational circuit.


Combinational circuit should use the input data as well as the data in the memory to generate output and the new memory content.


Here we consider Combiantional circuitdelaay to be less than the clock period.


##SETUP AND HOLD TIME:-
THERE ARE TWO TIMING BEFORE AND AFTER THE RISING EDGE BEFORE THE DATA IS STABLE AND MUST NOT CHANGE .
THE TIMING WINDOW BEFORE THE EDGE IS CALLED THE SETUP TIME AND THE ONE AFER THE EDGE IS CALLED HOLD TIME .
DURING THIS TIME THE D FLIP FLOP SAMPLE THE DATA AND SAVES INTO ITS STATE.
DURATION DEPEND ON THE UNDERLYING TECHNOLOGY IMPLEMENTING THE FLIP FLOPS  THUS THEY ARE FIXED AND CANNOT BE CHANGED OR CONTROLED.









